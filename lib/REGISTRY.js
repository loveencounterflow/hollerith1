// Generated by CoffeeScript 1.7.1
(function() {
  var $, ASYNC, KEY, P, TRM, TYPES, alert, badge, debug, echo, help, indexes, info, log, new_db, njs_fs, options, rainbow, registry, rpr, test_folder_exists, urge, warn, whisper,
    __slice = [].slice;

  njs_fs = require('fs');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIMETABLE/REGISTRY';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  options = require('../options');

  indexes = options['data']['indexes'];

  new_db = require('level');

  ASYNC = require('async');

  P = require('pipedreams');

  $ = P.$.bind(P);

  KEY = require('./KEY');

  test_folder_exists = function(route) {
    var is_folder;
    if (!njs_fs.existsSync(route)) {
      return false;
    }
    is_folder = (njs_fs.statSync(route)).isDirectory();
    if (!is_folder) {
      throw new Error("route exists but is not a folder: " + route);
    }
    return true;
  };

  this.new_registry = function(route) {
    if (route == null) {
      route = options['levelup']['route'];
    }
    return new_db(route, options['levelup']['new']);
  };

  this._new_registry = function(route) {
    var folder_exists, registry;
    if (route == null) {
      route = options['levelup']['route'];
    }
    folder_exists = test_folder_exists(route);
    registry = this.new_registry(route);
    return [folder_exists, registry];
  };

  this.close = function(registry, handler) {
    return registry.close((function(_this) {
      return function(error) {
        help('registry closed');
        return handler(error);
      };
    })(this));
  };

  this.flush = function(registry, handler) {
    return registry.close((function(_this) {
      return function(error) {
        if (error != null) {
          return handler(error);
        }
        return registry.open(function(error) {
          help('registry flushed');
          return handler(error, registry);
        });
      };
    })(this));
  };

  this.register = function(registry, record, handler) {
    var id, value;
    id = record['id'];
    if (id == null) {
      throw new Error("unable to register record without ID:\n" + (rpr(record)));
    }

    /* Records whose only attribute is the ID field are replaced by `1`: */
    value = (Object.keys(record)).length === 1 ? 1 : record;
    return registry.put(id, value, (function(_this) {
      return function(error) {
        if (error != null) {
          return handler(error);
        }
        return handler(null, record);
      };
    })(this));
  };

  this.$register = function(registry) {
    return $((function(_this) {
      return function(record, handler) {
        return _this.register(registry, record, function(error) {
          if (error != null) {
            return handler(error);
          }
          return handler(null, record);
        });
      };
    })(this));
  };

  this.register_2 = function(registry, record, handler) {

    /* TAINT kludge, change to using strings as records */
    var entries, facet_route, has_index, has_primary, has_secondary, id, id_1, idn, idn_1, key, meta_value, name, realm, realm_1, route, tasks, type, type_1, value, _ref, _ref1, _ref10, _ref11, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    id = record['id'];
    if (id == null) {
      throw new Error("unable to register record without ID:\n" + (rpr(record)));
    }
    meta_value = '1';
    entries = [];

    /* TAINT kludge, must be changed in GTFS reader */
    _ref = id.split('/'), realm = _ref[0], type = _ref[1], idn = _ref[2];
    route = KEY.new_route(realm, type);
    key = KEY.new_node(realm, type, idn);
    entries.push([key, JSON.stringify(record)]);
    for (name in record) {
      value = record[name];

      /* TAINT make configurable */
      if (name === 'id') {
        continue;
      }
      if (name === 'gtfs-id') {
        continue;
      }
      if (name === 'gtfs-type') {
        continue;
      }
      facet_route = KEY.new_route(realm, type, name);
      if ((has_index = (_ref1 = indexes['direct']) != null ? _ref1['facet'] : void 0) != null) {
        has_primary = (_ref2 = (_ref3 = has_index['primary']) != null ? _ref3[facet_route] : void 0) != null ? _ref2 : false;
        has_secondary = (_ref4 = (_ref5 = has_index['secondary']) != null ? _ref5[facet_route] : void 0) != null ? _ref4 : false;
        if (has_primary || has_secondary) {
          if (has_primary) {
            key = KEY.new_facet(realm, type, idn, name, value);
            entries.push([key, meta_value]);
          }
          if (has_secondary) {
            key = KEY.new_secondary_facet(realm, type, idn, name, value);
            entries.push([key, meta_value]);
          }
        }
      }
      if ((has_index = (_ref6 = indexes['direct']) != null ? _ref6['link'] : void 0) != null) {
        has_primary = (_ref7 = (_ref8 = has_index['primary']) != null ? _ref8[facet_route] : void 0) != null ? _ref7 : false;
        has_secondary = (_ref9 = (_ref10 = has_index['secondary']) != null ? _ref10[facet_route] : void 0) != null ? _ref9 : false;
        if (has_primary || has_secondary) {

          /* TAINT inefficiently first splitting, then joining */
          id_1 = value;
          _ref11 = KEY.split_id(id_1), realm_1 = _ref11[0], type_1 = _ref11[1], idn_1 = _ref11[2];
          if (has_primary) {
            key = KEY.new_link(realm, type, idn, realm_1, type_1, idn_1, 0);
            entries.push([key, meta_value]);
          }
          if (has_secondary) {
            key = KEY.new_secondary_link(realm, type, idn, realm_1, type_1, idn_1, 0);
            entries.push([key, meta_value]);
          }
        }
      }
    }
    tasks = (function() {
      var _i, _len, _ref12, _results;
      _results = [];
      for (_i = 0, _len = entries.length; _i < _len; _i++) {
        _ref12 = entries[_i], key = _ref12[0], value = _ref12[1];
        _results.push({
          type: 'put',
          key: key,
          value: value
        });
      }
      return _results;
    })();
    return registry.batch(tasks, (function(_this) {
      return function(error) {
        return handler(error != null ? error : null);
      };
    })(this));
  };

  this.$register_2 = function(registry) {
    return $((function(_this) {
      return function(record, handler) {
        return _this.register_2(registry, record, function(error) {
          if (error != null) {
            return handler(error);
          }
          return handler(null, record);
        });
      };
    })(this));
  };

  this.$count = function(registry, realm, type) {
    var count, on_data, on_end;
    count = 0;
    on_data = function(record) {
      count += 1;
      return this.emit('data', record);
    };
    on_end = function(record) {
      var key;
      key = KEY.new_node('µ', realm, type, 'count');
      return registry.put(key, count, (function(_this) {
        return function(error) {
          if (error != null) {
            return _this.emit('error', error);
          }
          return _this.emit('end');
        };
      })(this));
    };
    return P.through(on_data, on_end);
  };

  this.register_inferred_properties = function(registry, handler) {
    var compound_selector, count, count_key, entry_type, level, level_index, realm, source_selector, target_facet_name, target_facet_names, type, type_index, _ref, _results;
    count = 0;
    _ref = indexes['inferred'];
    _results = [];
    for (entry_type in _ref) {
      type_index = _ref[entry_type];
      _results.push((function() {
        var _results1;
        _results1 = [];
        for (level in type_index) {
          level_index = type_index[level];
          _results1.push((function() {
            var _i, _len, _ref1, _ref2, _results2;
            _results2 = [];
            for (_i = 0, _len = level_index.length; _i < _len; _i++) {
              compound_selector = level_index[_i];
              _ref1 = KEY.split_compound_selector(compound_selector), source_selector = _ref1[0], target_facet_names = 2 <= _ref1.length ? __slice.call(_ref1, 1) : [];
              if (target_facet_names.length !== 1) {
                warn("multiple target names are not yet implemented");
                continue;
              }
              target_facet_name = target_facet_names[0];
              _ref2 = KEY.split_id((KEY.read(source_selector))['id']), realm = _ref2[0], type = _ref2[1];
              count_key = KEY.new_node('µ', realm, type, 'count');
              _results2.push(registry.get(count_key, (function(_this) {
                return function(error, count) {
                  var input;
                  if (error != null) {
                    return handler(error);
                  }
                  debug(count_key, count);
                  input = _this._rdp_key_stream_from_prefix(registry, source_selector);
                  return P.pimp_readstream(input, count, "" + realm + "/" + type + "|").pipe(_this.$_rdp_proxy_from_source()).pipe(_this.$_rdp_add_target_key(level, entry_type, target_facet_name)).pipe(P.$pick('target-key')).pipe($(function(target_key, handler) {
                    return handler(null, {
                      key: target_key,
                      value: '1'
                    });
                  })).pipe(P.duplex(registry.createWriteStream(), input)).on('end', function() {
                    return handler(null);
                  });
                };
              })(this)));
            }
            return _results2;
          }).call(this));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };


  /* TAINT code duplication */


  /* TAINT wrong place for method */

  this._rdp_read_stream_from_prefix = function(registry, prefix) {
    var query;
    query = {
      gte: prefix,
      lte: KEY.lte_from_gte(prefix)
    };
    return registry.createReadStream(query);
  };

  this._rdp_key_stream_from_prefix = function(registry, prefix) {
    var query;
    query = {
      gte: prefix,
      lte: KEY.lte_from_gte(prefix)
    };
    return registry.createKeyStream(query);
  };

  this._rdp_value_stream_from_prefix = function(registry, prefix) {
    var query;
    query = {
      gte: prefix,
      lte: KEY.lte_from_gte(prefix)
    };
    return registry.createValueStream(query);
  };

  this.$_rdp_proxy_from_source = function() {
    return $((function(_this) {
      return function(source_key, handler) {

        /* TAINT specific to links */
        var Z, source_entry, _ref, _ref1;
        Z = {
          'source-entry': source_entry = KEY.read(source_key),
          'source-node-id': source_entry['id'],
          'proxy-node-id': source_entry['target']
        };

        /* TAINT inefficiently splitting and joining key */
        _ref = KEY.split_id(Z['source-node-id']), Z['source-realm'] = _ref[0], Z['source-type'] = _ref[1], Z['source-idn'] = _ref[2];

        /* TAINT inefficiently splitting and joining key */
        _ref1 = KEY.split_id(Z['proxy-node-id']), Z['proxy-realm'] = _ref1[0], Z['proxy-type'] = _ref1[1], Z['proxy-idn'] = _ref1[2];
        Z['proxy-node-key'] = KEY.new_node(Z['proxy-realm'], Z['proxy-type'], Z['proxy-idn']);
        return registry.get(Z['proxy-node-key'], function(error, proxy_node) {
          if (error != null) {
            return handler(error);
          }

          /* TAINT why is this not done automatically? */
          Z['proxy-node'] = JSON.parse(proxy_node);
          return handler(null, Z);
        });
      };
    })(this));
  };

  this.$_rdp_add_target_key = function(level, entry_type, target_facet_name) {
    return $((function(_this) {
      return function(proxy_info, handler) {
        var distance, proxy_node, target_idn, target_key, target_realm, target_type, target_value, _ref;
        proxy_node = proxy_info['proxy-node'];
        target_value = proxy_node[target_facet_name];

        /* TAINT kludge */
        if (target_value == null) {
          return handler(new Error("facet " + (rpr(target_facet_name)) + " not defined in " + (rpr(target_node))));
        }
        switch (level) {
          case 'secondary':
            switch (entry_type) {
              case 'link':

                /* TAINT inefficiently splitting and joining key */
                _ref = KEY.split_id(target_value), target_realm = _ref[0], target_type = _ref[1], target_idn = _ref[2];
                distance = proxy_info['source-entry']['distance'] + 1;
                target_key = KEY.new_secondary_link(proxy_info['source-realm'], proxy_info['source-type'], proxy_info['source-idn'], target_realm, target_type, target_idn, distance);
                break;
              default:
                return handler(new Error("not implemented"));
            }
            break;
          default:
            return handler(new Error("not implemented"));
        }
        proxy_info['target-key'] = target_key;
        return handler(null, proxy_info);
      };
    })(this));
  };

  if (module.parent == null) {
    registry = this.new_registry();
    this.register_inferred_properties(registry, function(error, data) {
      if (error != null) {
        throw error;
      }
      return help(data);
    });
  }

}).call(this);
