// Generated by CoffeeScript 1.7.1
(function() {
  var M, TRM, TYPES, alert, badge, debug, echo, help, info, log, njs_fs, options, rainbow, rpr, urge, warn, whisper,
    __slice = [].slice;

  njs_fs = require('fs');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'HOLLERITH/KEY';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  options = require('../../options');

  M = options['marks'];


  /*
   *===========================================================================================================
  
  888b    888 8888888888 888       888
  8888b   888 888        888   o   888
  88888b  888 888        888  d8b  888
  888Y88b 888 8888888    888 d888b 888
  888 Y88b888 888        888d88888b888
  888  Y88888 888        88888P Y88888
  888   Y8888 888        8888P   Y8888
  888    Y888 8888888888 888P     Y888
  
  
   *===========================================================================================================
   */

  this.new_key = function() {
    var complement, complement_esc, datatype, idx, idxs, index_count, pad, predicate, predicate_esc, schema, theme, theme_esc, topic, topic_esc, type;
    schema = arguments[0], theme = arguments[1], topic = arguments[2], predicate = arguments[3], complement = arguments[4], idx = 6 <= arguments.length ? __slice.call(arguments, 5) : [];

    /* TAINT should go to `hollerith/KEY` */
    if ((datatype = schema[predicate]) == null) {
      throw new Error("unknown datatype " + (rpr(predicate)));
    }
    index_count = datatype['index-count'], type = datatype.type, pad = datatype.pad;
    if (index_count !== idx.length) {
      throw new Error("need " + index_count + " indices for predicate " + (rpr(predicate)) + ", got " + idx.length);
    }
    theme_esc = KEY.esc(theme);
    topic_esc = KEY.esc(topic);
    predicate_esc = KEY.esc(predicate);
    complement_esc = KEY.esc(complement);

    /* TAINT parametrize */
    idxs = index_count === 0 ? '' : idxs.join(',');
    return 's' + '|' + theme_esc + '|' + topic_esc + '|' + predicate_esc + '|' + complement_esc + '|' + idxs;
  };


  /*
   *===========================================================================================================
  
   .d88888b.  888      8888888b.
  d88P" "Y88b 888      888  "Y88b
  888     888 888      888    888
  888     888 888      888    888
  888     888 888      888    888
  888     888 888      888    888
  Y88b. .d88P 888      888  .d88P
   "Y88888P"  88888888 8888888P"
  
  
   *===========================================================================================================
   */

  this.new_route = function(realm, type, name) {
    var R, part;
    R = [realm, type];
    if (name != null) {
      R.push(name);
    }
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = R.length; _i < _len; _i++) {
        part = R[_i];
        _results.push(this.esc(part));
      }
      return _results;
    }).call(this)).join(M['slash']);
  };

  this.new_id = function(realm, type, idn) {
    var slash;
    slash = M['slash'];
    return (this.new_route(realm, type)) + slash + (this.esc(idn));
  };

  this.new_node = function() {
    var R, crumb, idn, joiner, realm, tail, type;
    realm = arguments[0], type = arguments[1], idn = arguments[2], tail = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    joiner = M['joiner'];
    R = M['primary'] + M['node'] + joiner + (this.new_id(realm, type, idn));
    if (tail.length > 0) {
      R += M['slash'] + (((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = tail.length; _i < _len; _i++) {
          crumb = tail[_i];
          _results.push(this.esc(crumb));
        }
        return _results;
      }).call(this)).join(M['slash']));
    }
    R += joiner;
    return R;
  };

  this.new_secondary_node = function() {
    var R, crumb, idn, joiner, realm, slash, tail, type;
    realm = arguments[0], type = arguments[1], idn = arguments[2], tail = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    joiner = M['joiner'];
    slash = M['slash'];
    R = M['secondary'] + M['node'] + slash + (this.esc(realm)) + (this.esc(type));
    if (tail.length > 0) {
      R += joiner + (((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = tail.length; _i < _len; _i++) {
          crumb = tail[_i];
          _results.push(this.esc(crumb));
        }
        return _results;
      }).call(this)).join(slash));
    }
    R += joiner + (this.esc(idn)) + joiner;
    return R;
  };

  this.new_facet_pair = function(realm, type, idn, name, value, distance) {
    if (distance == null) {
      distance = 0;
    }
    return [this.new_facet(realm, type, idn, name, value, distance), this.new_secondary_facet(realm, type, idn, name, value, distance)];
  };

  this.new_facet = function(realm, type, idn, name, value, distance) {
    var joiner;
    if (distance == null) {
      distance = 0;
    }
    joiner = M['joiner'];
    return M['primary'] + M['facet'] + joiner + (this.new_id(realm, type, idn)) + joiner + (this.esc(name)) + joiner + (this.esc(value)) + joiner + distance + joiner;
  };

  this.new_secondary_facet = function(realm, type, idn, name, value, distance) {
    var joiner;
    if (distance == null) {
      distance = 0;
    }
    joiner = M['joiner'];
    return M['secondary'] + M['facet'] + joiner + (this.new_route(realm, type)) + joiner + (this.esc(name)) + joiner + (this.esc(value)) + joiner + (this.esc(idn)) + joiner + distance + joiner;
  };

  this.new_link_pair = function(realm_0, type_0, idn_0, realm_1, type_1, idn_1, distance) {
    if (distance == null) {
      distance = 0;
    }
    return [this.new_link(realm_0, type_0, idn_0, realm_1, type_1, idn_1, distance), this.new_secondary_link(realm_0, type_0, idn_0, realm_1, type_1, idn_1, distance)];
  };

  this.new_link = function(realm_0, type_0, idn_0, realm_1, type_1, idn_1, distance) {
    var joiner;
    if (distance == null) {
      distance = 0;
    }
    joiner = M['joiner'];
    return M['primary'] + M['link'] + joiner + (this.new_id(realm_0, type_0, idn_0)) + joiner + (this.new_id(realm_1, type_1, idn_1)) + joiner + distance + joiner;
  };

  this.new_secondary_link = function(realm_0, type_0, idn_0, realm_1, type_1, idn_1, distance) {
    var joiner;
    if (distance == null) {
      distance = 0;
    }
    joiner = M['joiner'];
    return M['secondary'] + M['link'] + joiner + (this.new_route(realm_0, type_0)) + joiner + (this.new_id(realm_1, type_1, idn_1)) + joiner + (this.esc(idn_0)) + joiner + distance + joiner;
  };

  this.read = function(key) {
    var R, fields, layer, type, _ref, _ref1;
    _ref = key.split(M['joiner']), (_ref1 = _ref[0], layer = _ref1[0], type = _ref1[1]), fields = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
    switch (layer) {
      case M['primary']:
        switch (type) {
          case M['node']:
            R = this._read_primary_node.apply(this, fields);
            break;
          case M['facet']:
            R = this._read_primary_facet.apply(this, fields);
            break;
          case M['link']:
            R = this._read_primary_link.apply(this, fields);
            break;
          default:
            throw new Error("unknown type mark " + (rpr(type)));
        }
        break;
      case M['secondary']:
        switch (type) {
          case M['facet']:
            R = this._read_secondary_facet.apply(this, fields);
            break;
          case M['link']:
            R = this._read_secondary_link.apply(this, fields);
            break;
          default:
            throw new Error("unknown type mark " + (rpr(type)));
        }
        break;
      default:
        throw new Error("unknown layer mark " + (rpr(layer)));
    }
    R['key'] = key;
    return R;
  };

  this._read_primary_node = function(id) {
    var R;
    R = {
      level: 'primary',
      type: 'node',
      id: id
    };
    return R;
  };

  this._read_primary_facet = function(id, name, value, distance) {
    var R;
    R = {
      level: 'primary',
      type: 'facet',
      id: id,
      name: name,
      value: value,
      distance: parseInt(distance, 10)
    };
    return R;
  };

  this._read_primary_link = function(id_0, id_1, distance) {
    var R;
    R = {
      level: 'primary',
      type: 'link',
      id: id_0,
      target: id_1,
      distance: parseInt(distance, 10)
    };
    return R;
  };

  this._read_secondary_facet = function(route, name, value, idn, distance) {
    var R;
    R = {
      level: 'secondary',
      type: 'facet',
      id: route + M['slash'] + idn,
      name: name,
      value: value,
      distance: parseInt(distance, 10)
    };
    return R;
  };

  this._read_secondary_link = function(route_0, id_1, idn_0, distance) {
    var R, id_0;
    id_0 = route_0 + M['slash'] + idn_0;
    R = {
      level: 'secondary',
      type: 'link',
      id: id_0,
      target: id_1,
      distance: parseInt(distance, 10)
    };
    return R;
  };

  this.infer = function(key_0, key_1) {
    return this._infer(key_0, key_1, 'primary');
  };

  this.infer_secondary = function(key_0, key_1) {
    return this._infer(key_0, key_1, 'secondary');
  };

  this.infer_pair = function(key_0, key_1) {
    return this._infer(key_0, key_1, 'pair');
  };

  this._infer = function(key_0, key_1, mode) {
    var id_1, id_2, info_0, info_1, type_0, type_1;
    info_0 = TYPES.isa_text(key_0) ? this.read(key_0) : key_0;
    info_1 = TYPES.isa_text(key_1) ? this.read(key_1) : key_1;
    if ((type_0 = info_0['type']) === 'link') {
      if ((id_1 = info_0['target']) !== (id_2 = info_1['id'])) {
        throw new Error("unable to infer link from " + (rpr(info_0['key'])) + " and " + (rpr(info_1['key'])));
      }
      switch (type_1 = info_1['type']) {
        case 'link':
          return this._infer_link(info_0, info_1, mode);
        case 'facet':
          return this._infer_facet(info_0, info_1, mode);
      }
    }
    throw new Error("expected a link plus a link or a facet, got a " + type_0 + " and a " + type_1);
  };

  this._infer_facet = function(link, facet, mode) {
    var distance, facet_idn, facet_realm, facet_type, link_idn, link_realm, link_type, name, slash, value, _ref, _ref1;
    _ref = this.split_id(link['id']), link_realm = _ref[0], link_type = _ref[1], link_idn = _ref[2];
    _ref1 = this.split_id(link['id']), facet_realm = _ref1[0], facet_type = _ref1[1], facet_idn = _ref1[2];

    /* TAINT route not distinct from ID? */

    /* TAINT should slashes in name be escaped? */

    /* TAINT what happens when we infer from an inferred facet? do all the escapes get re-escaped? */

    /* TAINT use module method */
    slash = M['slash'];

    /* TAINT make use of dash configurable */
    name = (this.esc(facet_realm)) + '-' + (this.esc(facet_type)) + '-' + (this.esc(facet['name']));
    value = facet['value'];
    distance = link['distance'] + facet['distance'] + 1;
    switch (mode) {
      case 'primary':
        return this.new_facet(link_realm, link_type, link_idn, name, value, distance);
      case 'secondary':
        return this.new_secondary_facet(link_realm, link_type, link_idn, name, value, distance);
      case 'pair':
        return this.new_facet_pair(link_realm, link_type, link_idn, name, value, distance);
      default:
        throw new Error("unknown mode " + (rpr(mode)));
    }
  };

  this._infer_link = function(link_0, link_1, mode) {

    /*
      $^|gtfs/stoptime/876|0|gtfs/trip/456
    +                   $^|gtfs/trip/456|0|gtfs/route/777
    ----------------------------------------------------------------
    = $^|gtfs/stoptime/876|1|gtfs/route/777
    = %^|gtfs/stoptime|1|gtfs/route/777|876
     */
    var distance, idn_0, idn_2, realm_0, realm_2, type_0, type_2, _ref, _ref1;
    _ref = this.split_id(link_0['id']), realm_0 = _ref[0], type_0 = _ref[1], idn_0 = _ref[2];
    _ref1 = this.split_id(link_1['target']), realm_2 = _ref1[0], type_2 = _ref1[1], idn_2 = _ref1[2];
    distance = link_0['distance'] + link_1['distance'] + 1;
    switch (mode) {
      case 'primary':
        return this.new_link(realm_0, type_0, idn_0, realm_2, type_2, idn_2, distance);
      case 'secondary':
        return this.new_secondary_link(realm_0, type_0, idn_0, realm_2, type_2, idn_2, distance);
      case 'pair':
        return this.new_link_pair(realm_0, type_0, idn_0, realm_2, type_2, idn_2, distance);
      default:
        throw new Error("unknown mode " + (rpr(mode)));
    }
  };

  this.esc = (function() {
    var d, escape, joiner_matcher, joiner_replacer;
    escape = function(text) {
      var R;
      R = text;
      R = R.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1');
      R = R.replace(/\x08/g, '\\x08');
      return R;
    };
    joiner_matcher = new RegExp(escape(M['joiner']), 'g');
    joiner_replacer = ((function() {
      var _i, _len, _ref, _results;
      _ref = new Buffer(M['joiner']);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        d = _ref[_i];
        _results.push('µ' + d.toString(16));
      }
      return _results;
    })()).join('');
    return function(x) {
      var R;
      if (x === void 0) {
        throw new Error("value cannot be undefined");
      }
      R = TYPES.isa_text(x) ? x : rpr(x);
      R = R.replace(/µ/g, 'µb5');
      R = R.replace(joiner_matcher, joiner_replacer);
      return R;
    };
  })();

  this.split_id = function(id) {

    /* TAINT must unescape */
    var R, slash;
    R = id.split(slash = M['slash']);
    if (R.length !== 3) {
      throw new Error("expected three parts separated by " + (rpr(slash)) + ", got " + (rpr(id)));
    }
    if (!(R[0].length > 0)) {
      throw new Error("realm cannot be empty in " + (rpr(id)));
    }
    if (!(R[1].length > 0)) {
      throw new Error("type cannot be empty in " + (rpr(id)));
    }
    if (!(R[2].length > 0)) {
      throw new Error("IDN cannot be empty in " + (rpr(id)));
    }
    return R;
  };

  this.split = function(x) {
    return x.split(M['joiner']);
  };

  this.split_compound_selector = function(compound_selector) {

    /* TAINT must unescape */
    return compound_selector.split(M['loop']);
  };

  this._idn_from_id = function(id) {
    var match;
    match = id.replace(/^.+?([^\/]+)$/);
    if (match == null) {
      throw new Error("not a valid ID: " + (rpr(id)));
    }
    return match[1];
  };

  this.lte_from_gte = function(gte) {
    var R, length;
    length = Buffer.byteLength(gte);
    R = new Buffer(1 + length);
    R.write(gte);
    R[length] = 0xff;
    return R;
  };

  if (module.parent == null) {
    help(this.new_id('gtfs', 'stop', '123'));
    help(this.new_facet('gtfs', 'stop', '123', 'name', 1234));
    help(this.new_facet('gtfs', 'stop', '123', 'name', 'foo/bar|baz'));
    help(this.new_facet('gtfs', 'stop', '123', 'name', 'Bayerischer Platz'));
    help(this.new_secondary_facet('gtfs', 'stop', '123', 'name', 'Bayerischer Platz'));
    help(this.new_facet_pair('gtfs', 'stop', '123', 'name', 'Bayerischer Platz'));
    help(this.new_link('gtfs', 'stoptime', '456', 'gtfs', 'stop', '123'));
    help(this.new_secondary_link('gtfs', 'stoptime', '456', 'gtfs', 'stop', '123'));
    help(this.new_link_pair('gtfs', 'stoptime', '456', 'gtfs', 'stop', '123'));
    help(this.read(this.new_facet('gtfs', 'stop', '123', 'name', 'Bayerischer Platz')));
    help(this.read(this.new_secondary_facet('gtfs', 'stop', '123', 'name', 'Bayerischer Platz')));
    help(this.read(this.new_link('gtfs', 'stoptime', '456', 'gtfs', 'stop', '123')));
    help(this.read(this.new_secondary_link('gtfs', 'stoptime', '456', 'gtfs', 'stop', '123')));
    help(this.infer('$^|gtfs/stoptime/876|0|gtfs/trip/456', '$^|gtfs/trip/456|0|gtfs/route/777'));
    help(this.infer('$^|gtfs/stoptime/876|0|gtfs/trip/456', '%^|gtfs/trip|0|gtfs/route/777|456'));
    help(this.infer('$^|gtfs/trip/456|0|gtfs/stop/123', '$:|gtfs/stop/123|0|name|Bayerischer Platz'));
    help(this.infer('$^|gtfs/stoptime/876|1|gtfs/stop/123', '$:|gtfs/stop/123|0|name|Bayerischer Platz'));
  }

}).call(this);
