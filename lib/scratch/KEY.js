// Generated by CoffeeScript 1.7.1
(function() {
  var M, TRM, TYPES, alert, badge, debug, echo, help, info, log, njs_fs, options, rainbow, rpr, urge, warn, whisper,
    __slice = [].slice;

  njs_fs = require('fs');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'HOLLERITH/KEY';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  options = require('../../options');

  M = options['marks'];

  this.new_route = function(realm, type, name) {
    var R, part;
    R = [realm, type];
    if (name != null) {
      R.push(name);
    }
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = R.length; _i < _len; _i++) {
        part = R[_i];
        _results.push(this.esc(part));
      }
      return _results;
    }).call(this)).join(M['slash']);
  };

  this.new_id = function(realm, type, idn) {
    var slash;
    slash = M['slash'];
    return (this.new_route(realm, type)) + slash + (this.esc(idn));
  };

  this.new_node = function() {
    var R, crumb, idn, joiner, realm, tail, type;
    realm = arguments[0], type = arguments[1], idn = arguments[2], tail = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    joiner = M['joiner'];
    R = M['primary'] + M['node'] + joiner + (this.new_id(realm, type, idn));
    if (tail.length > 0) {
      R += M['slash'] + (((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = tail.length; _i < _len; _i++) {
          crumb = tail[_i];
          _results.push(this.esc(crumb));
        }
        return _results;
      }).call(this)).join(M['slash']));
    }
    R += joiner;
    return R;
  };

  this.new_facet_pair = function(realm, type, idn, name, value, distance) {
    if (distance == null) {
      distance = 0;
    }
    return [this.new_facet(realm, type, idn, name, value, distance), this.new_secondary_facet(realm, type, idn, name, value, distance)];
  };

  this.new_facet = function(realm, type, idn, name, value, distance) {
    var joiner;
    if (distance == null) {
      distance = 0;
    }
    joiner = M['joiner'];
    return M['primary'] + M['facet'] + joiner + (this.new_id(realm, type, idn)) + joiner + (this.esc(name)) + joiner + (this.esc(value)) + joiner + distance + joiner;
  };

  this.new_secondary_facet = function(realm, type, idn, name, value, distance) {
    var joiner;
    if (distance == null) {
      distance = 0;
    }
    joiner = M['joiner'];
    return M['secondary'] + M['facet'] + joiner + (this.new_route(realm, type)) + joiner + (this.esc(name)) + joiner + (this.esc(value)) + joiner + (this.esc(idn)) + joiner + distance + joiner;
  };

  this.new_link_pair = function(realm_0, type_0, idn_0, realm_1, type_1, idn_1, distance) {
    if (distance == null) {
      distance = 0;
    }
    return [this.new_link(realm_0, type_0, idn_0, realm_1, type_1, idn_1, distance), this.new_secondary_link(realm_0, type_0, idn_0, realm_1, type_1, idn_1, distance)];
  };

  this.new_link = function(realm_0, type_0, idn_0, realm_1, type_1, idn_1, distance) {
    var joiner;
    if (distance == null) {
      distance = 0;
    }
    joiner = M['joiner'];
    return M['primary'] + M['link'] + joiner + (this.new_id(realm_0, type_0, idn_0)) + joiner + (this.new_id(realm_1, type_1, idn_1)) + joiner + distance + joiner;
  };

  this.new_secondary_link = function(realm_0, type_0, idn_0, realm_1, type_1, idn_1, distance) {
    var joiner;
    if (distance == null) {
      distance = 0;
    }
    joiner = M['joiner'];
    return M['secondary'] + M['link'] + joiner + (this.new_route(realm_0, type_0)) + joiner + (this.new_id(realm_1, type_1, idn_1)) + joiner + (this.esc(idn_0)) + joiner + distance + joiner;
  };

  this.read = function(key) {
    var R, fields, layer, type, _ref, _ref1;
    _ref = key.split(M['joiner']), (_ref1 = _ref[0], layer = _ref1[0], type = _ref1[1]), fields = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
    switch (layer) {
      case M['primary']:
        switch (type) {
          case M['node']:
            R = this._read_primary_node.apply(this, fields);
            break;
          case M['facet']:
            R = this._read_primary_facet.apply(this, fields);
            break;
          case M['link']:
            R = this._read_primary_link.apply(this, fields);
            break;
          default:
            throw new Error("unknown type mark " + (rpr(type)));
        }
        break;
      case M['secondary']:
        switch (type) {
          case M['facet']:
            R = this._read_secondary_facet.apply(this, fields);
            break;
          case M['link']:
            R = this._read_secondary_link.apply(this, fields);
            break;
          default:
            throw new Error("unknown type mark " + (rpr(type)));
        }
        break;
      default:
        throw new Error("unknown layer mark " + (rpr(layer)));
    }
    R['key'] = key;
    return R;
  };

  this._read_primary_node = function(id) {
    var R;
    R = {
      level: 'primary',
      type: 'node',
      id: id
    };
    return R;
  };

  this._read_primary_facet = function(id, name, value, distance) {
    var R;
    R = {
      level: 'primary',
      type: 'facet',
      id: id,
      name: name,
      value: value,
      distance: parseInt(distance, 10)
    };
    return R;
  };

  this._read_primary_link = function(id_0, id_1, distance) {
    var R;
    R = {
      level: 'primary',
      type: 'link',
      id: id_0,
      target: id_1,
      distance: parseInt(distance, 10)
    };
    return R;
  };

  this._read_secondary_facet = function(route, name, value, idn, distance) {
    var R;
    R = {
      level: 'secondary',
      type: 'facet',
      id: route + M['slash'] + idn,
      name: name,
      value: value,
      distance: parseInt(distance, 10)
    };
    return R;
  };

  this._read_secondary_link = function(route_0, id_1, idn_0, distance) {
    var R, id_0;
    id_0 = route_0 + M['slash'] + idn_0;
    R = {
      level: 'secondary',
      type: 'link',
      id: id_0,
      target: id_1,
      distance: parseInt(distance, 10)
    };
    return R;
  };

  this.infer = function(key_0, key_1) {
    var id_1, id_2, info_0, info_1, type_0, type_1;
    info_0 = TYPES.isa_text(key_0) ? this.read(key_0) : key_0;
    info_1 = TYPES.isa_text(key_1) ? this.read(key_1) : key_1;
    if ((type_0 = info_0['type']) === 'link') {
      if ((id_1 = info_0['target']) !== (id_2 = info_1['id'])) {
        throw new Error("unable to infer link from " + (rpr(info_0['key'])) + " and " + (rpr(info_1['key'])));
      }
      switch (type_1 = info_1['type']) {
        case 'link':
          return this._infer_link(info_0, info_1);
        case 'facet':
          return this._infer_facet(info_0, info_1);
      }
    }
    throw new Error("expected a link plus a link or a facet, got a " + type_0 + " and a " + type_1);
  };

  this._infer_facet = function(link, facet) {
    var distance, facet_idn, facet_realm, facet_type, link_idn, link_realm, link_type, name, slash, value, _ref, _ref1;
    _ref = this.split_id(link['id']), link_realm = _ref[0], link_type = _ref[1], link_idn = _ref[2];
    _ref1 = this.split_id(link['id']), facet_realm = _ref1[0], facet_type = _ref1[1], facet_idn = _ref1[2];

    /* TAINT route not distinct from ID? */

    /* TAINT should slashes in name be escaped? */

    /* TAINT what happens when we infer from an inferred facet? do all the escapes get re-escaped? */

    /* TAINT use module method */
    slash = M['slash'];
    name = (this.esc(facet_realm)) + slash + (this.esc(facet_type)) + slash + (this.esc(facet['name']));
    value = facet['value'];
    distance = link['distance'] + facet['distance'] + 1;
    return this.new_facet_pair(link_realm, link_type, link_idn, name, value, distance);
  };

  this._infer_link = function(link_0, link_1) {

    /*
      $^|gtfs/stoptime/876|0|gtfs/trip/456
    +                   $^|gtfs/trip/456|0|gtfs/route/777
    ----------------------------------------------------------------
    = $^|gtfs/stoptime/876|1|gtfs/route/777
    = %^|gtfs/stoptime|1|gtfs/route/777|876
     */
    var distance, idn_0, idn_2, realm_0, realm_2, type_0, type_2, _ref, _ref1;
    _ref = this.split_id(link_0['id']), realm_0 = _ref[0], type_0 = _ref[1], idn_0 = _ref[2];
    _ref1 = this.split_id(link_1['target']), realm_2 = _ref1[0], type_2 = _ref1[1], idn_2 = _ref1[2];
    distance = link_0['distance'] + link_1['distance'] + 1;
    return this.new_link_pair(realm_0, type_0, idn_0, realm_2, type_2, idn_2, distance);
  };

  this.esc = (function() {
    var d, escape, joiner_matcher, joiner_replacer, loop_matcher, loop_replacer, slash_matcher, slash_replacer;
    escape = function(text) {
      var R;
      R = text;
      R = R.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1');
      R = R.replace(/\x08/g, '\\x08');
      return R;
    };
    joiner_matcher = new RegExp(escape(M['joiner']), 'g');
    slash_matcher = new RegExp(escape(M['slash']), 'g');
    loop_matcher = new RegExp(escape(M['loop']), 'g');
    joiner_replacer = ((function() {
      var _i, _len, _ref, _results;
      _ref = new Buffer(M['joiner']);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        d = _ref[_i];
        _results.push('%' + d.toString(16));
      }
      return _results;
    })()).join('');
    slash_replacer = ((function() {
      var _i, _len, _ref, _results;
      _ref = new Buffer(M['slash']);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        d = _ref[_i];
        _results.push('%' + d.toString(16));
      }
      return _results;
    })()).join('');
    loop_replacer = ((function() {
      var _i, _len, _ref, _results;
      _ref = new Buffer(M['loop']);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        d = _ref[_i];
        _results.push('%' + d.toString(16));
      }
      return _results;
    })()).join('');
    return function(x) {
      var R;
      if (x === void 0) {
        throw new Error("value cannot be undefined");
      }
      R = TYPES.isa_text(x) ? x : rpr(x);
      R = R.replace(/%/g, '%25');
      R = R.replace(joiner_matcher, joiner_replacer);
      R = R.replace(slash_matcher, slash_replacer);
      R = R.replace(loop_matcher, loop_replacer);
      return R;
    };
  })();

  this.split_id = function(id) {

    /* TAINT must unescape */
    var R, slash;
    R = id.split(slash = M['slash']);
    if (R.length !== 3) {
      throw new Error("expected three parts separated by " + (rpr(slash)) + ", got " + (rpr(id)));
    }
    if (!(R[0].length > 0)) {
      throw new Error("realm cannot be empty in " + (rpr(id)));
    }
    if (!(R[1].length > 0)) {
      throw new Error("type cannot be empty in " + (rpr(id)));
    }
    if (!(R[2].length > 0)) {
      throw new Error("IDN cannot be empty in " + (rpr(id)));
    }
    return R;
  };

  this.split = function(x) {
    return x.split(M['joiner']);
  };

  this.split_compound_selector = function(compound_selector) {

    /* TAINT must unescape */
    return compound_selector.split(M['loop']);
  };

  this._idn_from_id = function(id) {
    var match;
    match = id.replace(/^.+?([^\/]+)$/);
    if (match == null) {
      throw new Error("not a valid ID: " + (rpr(id)));
    }
    return match[1];
  };

  this.lte_from_gte = function(gte) {
    var R, length;
    length = Buffer.byteLength(gte);
    R = new Buffer(1 + length);
    R.write(gte);
    R[length] = 0xff;
    return R;
  };

  if (module.parent == null) {
    help(this.new_id('gtfs', 'stop', '123'));
    help(this.new_facet('gtfs', 'stop', '123', 'name', 1234));
    help(this.new_facet('gtfs', 'stop', '123', 'name', 'foo/bar|baz'));
    help(this.new_facet('gtfs', 'stop', '123', 'name', 'Bayerischer Platz'));
    help(this.new_secondary_facet('gtfs', 'stop', '123', 'name', 'Bayerischer Platz'));
    help(this.new_facet_pair('gtfs', 'stop', '123', 'name', 'Bayerischer Platz'));
    help(this.new_link('gtfs', 'stoptime', '456', 'gtfs', 'stop', '123'));
    help(this.new_secondary_link('gtfs', 'stoptime', '456', 'gtfs', 'stop', '123'));
    help(this.new_link_pair('gtfs', 'stoptime', '456', 'gtfs', 'stop', '123'));
    help(this.read(this.new_facet('gtfs', 'stop', '123', 'name', 'Bayerischer Platz')));
    help(this.read(this.new_secondary_facet('gtfs', 'stop', '123', 'name', 'Bayerischer Platz')));
    help(this.read(this.new_link('gtfs', 'stoptime', '456', 'gtfs', 'stop', '123')));
    help(this.read(this.new_secondary_link('gtfs', 'stoptime', '456', 'gtfs', 'stop', '123')));
    help(this.infer('$^|gtfs/stoptime/876|0|gtfs/trip/456', '$^|gtfs/trip/456|0|gtfs/route/777'));
    help(this.infer('$^|gtfs/stoptime/876|0|gtfs/trip/456', '%^|gtfs/trip|0|gtfs/route/777|456'));
    help(this.infer('$^|gtfs/trip/456|0|gtfs/stop/123', '$:|gtfs/stop/123|0|name|Bayerischer Platz'));
    help(this.infer('$^|gtfs/stoptime/876|1|gtfs/stop/123', '$:|gtfs/stop/123|0|name|Bayerischer Platz'));
  }

}).call(this);
